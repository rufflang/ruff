# Ruff Field Notes â€” Phase 4D: Guard Generation for Specialized Code

**Date:** 2026-01-27
**Session:** 11:15 local
**Branch/Commit:** main / e31ef91
**Scope:** Implemented type guards at function entry to protect specialized JIT code from invalid type assumptions. Guards check each specialized variable and branch to optimized code on success, or return error code on failure.

---

## What I Changed

- Modified `compile()` method in `src/jit.rs` to insert guard blocks at function entry
- Added guard generation loop that checks each specialized variable's type
- Created `guard_success_block` and `guard_failure_block` for conditional branching
- Used `brif` instruction to branch based on AND of all guard checks
- Sealed blocks properly: entry_block after branching, guard_success_block via normal flow
- Guard failure returns -1 (error code indicating deoptimization needed)
- Guard success branches to function body for optimized execution
- Added 3 new guard-specific tests (total: 28 JIT tests, 59 library tests)
- Tests:
  - `test_guard_generation_with_specialization` - Single variable guard
  - `test_compilation_without_guards_when_no_specialization` - No guards when no profile
  - `test_multiple_specialized_variables_guards` - Multiple guards ANDed together

---

## Gotchas (Read This Next Time)

### Gotcha 1: Block Sealing Order is Critical
- **Symptom:** Panic: "unsealed blocks after building function"
- **Root cause:** Entry block must be sealed AFTER branching from it, but guard_success_block must NOT be sealed immediately (normal flow handles it)
- **Fix:** 
  ```rust
  // After brif from entry_block:
  builder.seal_block(entry_block);
  
  // Do NOT seal guard_success_block here!
  // Let the normal sealing logic (after instruction translation) handle it
  ```
- **Prevention:** Only seal blocks after ALL jumps TO them are created. Entry block is special because we branch FROM it immediately. Success block gets more jumps later (from instruction translation flow).

### Gotcha 2: brif Takes Direct Boolean, Not Integer
- **Symptom:** Type error: "brif expects bool (b1), got i64"
- **Root cause:** Cranelift's `brif` instruction requires a boolean flag, not an integer. The integer comparison result IS a boolean.
- **Fix:** Use the `icmp` result directly:
  ```rust
  let guard_passed = builder.ins().icmp_imm(IntCC::Equal, check_result, 1);
  // guard_passed is already b1 (boolean)
  builder.ins().brif(guard_passed, success_block, &[], failure_block, &[]);
  ```
- **Prevention:** Don't try to convert i64 to bool with `brnz` or `bint`. `icmp` already returns bool.

### Gotcha 3: Guards Must Be ANDed for Multiple Variables
- **Symptom:** Function execution succeeds when one guard passes but another fails
- **Root cause:** Each guard check is independent; need to combine with AND
- **Fix:** Initialize `all_guards_passed` to true (1 as i64), then AND with each check:
  ```rust
  let mut all_guards_passed = builder.ins().iconst(types::I64, 1);
  for var in specialized_vars {
      let check_result = call_jit_check_type(var);
      let guard_passed = builder.ins().icmp_imm(IntCC::Equal, check_result, 1);
      all_guards_passed = builder.ins().band(all_guards_passed, guard_passed);
  }
  builder.ins().brif(all_guards_passed, success, failure);
  ```
- **Prevention:** Always AND guards together. ALL must pass for specialization to be safe.

### Gotcha 4: Entry Block Variable Scope Issue
- **Symptom:** Borrow checker error: "current_block used after move"
- **Root cause:** `current_block` was declared inside the guard generation block, so outer code couldn't see the updated value (guard_success_block)
- **Fix:** Declare `current_block` BEFORE guard generation:
  ```rust
  let mut current_block = entry_block; // Before guard logic
  if specialization.is_some() {
      // Generate guards, update current_block = guard_success_block
  }
  // Now current_block is visible outside if block
  ```
- **Prevention:** Declare mutable variables at the correct scope level for their usage.

### Gotcha 5: Guard Failure Returns -1, Not Exception
- **Symptom:** Confusion about how to signal deoptimization
- **Root cause:** We're in native code; can't throw Rust exceptions across FFI boundary
- **Fix:** Return -1 as error code:
  ```rust
  // In guard_failure_block:
  let error_code = builder.ins().iconst(types::I64, -1);
  builder.ins().return_(&[error_code]);
  ```
  Calling code checks return value: if -1, fall back to interpreter
- **Prevention:** Native JIT functions communicate errors via return values, not exceptions. -1 is the deopt signal.

---

## Things I Learned

### Mental Model: Guards as a Runtime Contract
- Guards are NOT a performance optimization â€” they're a **safety mechanism**
- Specialized code makes TYPE ASSUMPTIONS (e.g., "variable X is always an int")
- Guards CHECK those assumptions at function entry
- If assumptions hold â†’ run fast code
- If assumptions broken â†’ bail out safely
- This enables aggressive optimizations without correctness risk

### Mental Model: Guard Placement Strategy
- Guards go at function ENTRY, not per-operation
- Why? Because type specialization is FUNCTION-LEVEL, not operation-level
- A specialized function says "I assume ALL these variables have specific types FOR THE ENTIRE FUNCTION"
- Checking once at entry is sufficient (types don't change mid-function in Ruff)
- Alternative strategies (per-operation guards) would be too expensive

### Mental Model: Deoptimization is Lazy
- Guard failure doesn't trigger recompilation immediately
- It just returns -1, letting the interpreter take over
- Phase 4A's adaptive recompilation tracks failure frequency
- After ~10 failures, the profiler invalidates specialization
- New profile is collected, new specialized version is compiled
- This avoids thrashing when types are unstable

### Rule: Seal Entry Block After Branching From It
- Entry block is unique: we branch FROM it, but no other blocks branch TO it
- Must seal it immediately after creating outgoing branches (brif to success/failure)
- Other blocks are sealed after all incoming edges are established
- This is a Cranelift requirement for SSA form construction

### Rule: Return Values Signal Deoptimization
- JIT functions return i64
- Normal execution: return actual result value
- Guard failure: return -1 (reserved error code)
- Calling code (VM) checks: `if result == -1 { fall_back_to_interpreter() }`
- Future: VM can track failures and trigger recompilation

---

## Debug Notes

### Initial Panic: Unsealed Blocks
- **Failing test:** `test_guard_generation_with_specialization`
- **Error:** "unsealed blocks after building function"
- **Repro steps:** Compile function with specialization, try to finalize
- **Breakpoints / logs used:** 
  - Added `eprintln!("Sealing entry_block")` after brif
  - Checked Cranelift docs for block sealing rules
- **Final diagnosis:** Was trying to seal guard_success_block immediately, but it receives jumps from later instruction translation. Only entry_block should be sealed right after brif.

### Type Mismatch: brif Argument
- **Failing test:** `test_guard_generation_with_specialization`
- **Error:** Type error: "brif expects b1, got i64"
- **Repro steps:** Run test, examine Cranelift error message
- **Breakpoints / logs used:** Printed types of variables passed to brif
- **Final diagnosis:** Was trying to use integer comparison result in brnz, but brif wants the comparison result directly (which is already bool).

### Variable Scope: current_block Not Visible
- **Failing test:** Compilation error, not runtime
- **Error:** "cannot find value `current_block` in this scope"
- **Repro steps:** Cargo build after adding guard logic
- **Breakpoints / logs used:** N/A (compile-time error)
- **Final diagnosis:** `current_block` was declared inside `if let Some(spec) = specialization` block. Moved declaration outside to make it visible to instruction translation loop.

---

## Follow-ups / TODO (For Future Agents)

- [ ] **Performance Benchmarking**: Measure actual speedup of guarded specialized code vs. generic code
- [ ] **Guard Failure Integration**: Connect -1 return value to VM's adaptive recompilation system
- [ ] **Float Specialization**: Revisit Cranelift type conversion APIs for float-specialized guards
- [ ] **Guard Optimization**: Could we hoist guards out of hot loops? (Probably not needed - guards are at function entry)
- [ ] **Profiler Integration**: Ensure guard failures are counted in Phase 4A's TypeProfile system
- [ ] **Multiple Compilation Units**: Test guards with multiple specialized functions calling each other

---

## Links / References

- Files touched:
  - `src/jit.rs` (lines 1233-1298: guard generation, lines 1935-2110: new tests)
- Related docs:
  - `CHANGELOG.md` - Phase 4D section
  - `ROADMAP.md` - Phase 4 progress tracking
  - `README.md` - Phase 4D completion notes
  - `notes/2026-01-27_10-53_phase4b-specialized-codegen.md` - Previous session
  - `notes/2026-01-27_11-02_phase4c-integration.md` - Integration session
- Cranelift docs:
  - Block sealing: https://docs.rs/cranelift-frontend/latest/cranelift_frontend/struct.FunctionBuilder.html#method.seal_block
  - brif instruction: https://docs.rs/cranelift-codegen/latest/cranelift_codegen/ir/instructions/enum.InstructionData.html

---

## Key Insight: Why Guards Enable Aggressive Optimization

Guards are the KEY to making type specialization safe:

1. **Without guards**: Can't specialize because types might change â†’ must use generic slow path
2. **With guards**: Can specialize aggressively, knowing we'll catch type changes at entry

This is the same strategy used by:
- V8 JavaScript engine (type guards in optimized code)
- PyPy Python JIT (guard-based specialization)
- LuaJIT (trace guards)

The pattern: **Assume + Guard + Deopt** enables most of the performance of static typing without requiring type annotations.

Ruff now has this capability. Phase 4D is complete. ðŸŽ‰
