# Step 11: Loop Back-Edge Fix - Session Notes

**Date**: 2026-01-28  
**Duration**: ~1 hour  
**Status**: âœ… COMPLETE

## Summary

Fixed JIT compilation of loops with backward jumps (JumpBack opcode). The issue was that Cranelift's SSA form requires block parameters to be declared when blocks are created, but for backward jumps (loops), we don't know the stack depth until the jump instruction is processed.

## Problem Analysis

### Root Cause
When the JIT compiler encountered a `JumpBack` instruction (backward jump for loops), it would fail with Cranelift verifier errors because:

1. Loop header blocks had no parameters when created
2. When `JumpBack` was processed, we tried to pass stack values to a block expecting 0 arguments
3. Cranelift's SSA form requires all block predecessors to be known before sealing

### Error Message
```
VerifierError: mismatched argument count for `jump block3(v1)`: got 1, expected 0
```

## Solution

### 1. Pre-analyze Bytecode for Loop Headers
Added `analyze_loop_headers()` function that scans bytecode to find backward jump targets and calculates the expected stack depth at each loop header:

```rust
fn analyze_loop_headers(&self, instructions: &[OpCode]) -> std::collections::HashMap<usize, usize>
```

### 2. Calculate Stack Effects
Added `stack_effect()` function that returns (pops, pushes) for each opcode:

```rust
fn stack_effect(instruction: &OpCode) -> (usize, usize)
```

### 3. Track Loop Header Blocks
Added `loop_header_pcs: HashSet<usize>` to track which PCs are loop headers, so they can be treated specially during sealing.

### 4. Late Sealing for Loop Headers
Modified the sealing logic to NOT seal loop header blocks immediately. Instead, loop headers are sealed at the END of compilation, after all back-edges have been processed:

```rust
// Don't seal loop headers when switching blocks
if !translator.loop_header_pcs.iter().any(|&lpc| 
    translator.blocks.get(&lpc) == Some(&current_block)) {
    builder.seal_block(current_block);
}

// Seal all remaining blocks at the end
for (&pc, &block) in &translator.blocks {
    if !sealed_blocks.contains(&block) {
        builder.seal_block(block);
    }
}
```

### 5. Pass Stack Values on JumpBack
Modified `JumpBack` handling to pass current stack values as block arguments:

```rust
OpCode::JumpBack(target) => {
    let args: Vec<_> = self.value_stack.clone();
    builder.ins().jump(target_block, &args);
}
```

## Key Insight: StoreVar Semantics

During debugging, discovered that Ruff's `StoreVar` opcode PEEKS (doesn't pop) the stack. This is documented in GOTCHAS.md but the comment there was misleading.

- `StoreVar` uses `self.stack.last()` (PEEK, doesn't pop)
- Value remains on stack after assignment
- For proper loop bytecode, need explicit `Pop` after `StoreVar` to clean stack

The test bytecode was corrected to include `Pop` after `StoreVar` to ensure the stack is empty at the loop header on every iteration.

## Files Modified

1. **src/jit.rs**:
   - Added `analyze_loop_headers()` function
   - Added `stack_effect()` function
   - Added `loop_header_pcs` field to BytecodeTranslator
   - Modified `create_blocks()` to create loop header blocks with parameters
   - Modified JumpBack handling to pass stack values
   - Modified sealing logic to delay loop header sealing
   - Updated `test_compile_simple_loop` with correct bytecode pattern

2. **CHANGELOG.md**: Added Step 11 completion entry

3. **ROADMAP.md**: Updated Step 11 status to COMPLETE

4. **tests/jit_loop_tests.ruff**: Created comprehensive loop test file

## Tests

- All 31 JIT tests passing
- `test_compile_simple_loop` now passing (was previously failing)
- `tests/jit_loop_tests.ruff` runs correctly with all 5 tests passing

## Gotchas Discovered

1. **StoreVar semantics**: StoreVar PEEKS, doesn't POP. The GOTCHAS.md entry was confusing - it said "consuming operation" but the VM uses `stack.last()`.

2. **Assignment syntax**: Ruff uses `:=` for assignment, not `=`. The `=` operator is for equality or something else. This caused an infinite loop in my initial while loop test.

3. **Cranelift SSA**: Blocks must have all parameters declared at creation time. Can't add parameters after the block is visited or sealed.

## Performance Impact

Loops in JIT-compiled functions now work correctly. However, loops in top-level scripts still run interpreted because the JIT is function-level only (functions are JIT-compiled after 100 calls).

## Next Steps

Phase 7 is now 98% complete. Remaining work:
- Verify loop-based benchmarks (array sum, hash map) performance
- Consider extending JIT to hot loops in main script (lower priority)
- Prepare for v0.9.0 release
