# Comprehensive Binary File Operations Test Suite
#
# Tests for:
# - Binary file read/write operations
# - Base64 encoding/decoding
# - Binary data manipulation
# - Edge cases and error handling

print("=== Binary File Operations Test Suite ===")
print()

# Test 1: Write and read binary file
print("Test 1: Basic binary file read/write")
let test_data := "Hello, Binary World! ðŸŽ‰"
let test_file := "/tmp/ruff_binary_test_1.bin"

# Convert string to binary by encoding to base64 and back
# (In real use, you'd get binary data from http_get_binary, images, etc.)
let binary_data := decode_base64(encode_base64(test_data))

result := write_binary_file(test_file, binary_data)
if result {
    print("âœ“ Binary file written successfully")
    
    let read_back := read_binary_file(test_file)
    let decoded := encode_base64(read_back)
    let original := encode_base64(binary_data)
    
    if decoded == original {
        print("âœ“ Binary data matches after read/write cycle")
    } else {
        print("âœ— Binary data mismatch!")
    }
} else {
    print("âœ— Failed to write binary file")
}
print()

# Test 2: Base64 encoding/decoding round-trip
print("Test 2: Base64 encoding/decoding")
let test_strings := ["Hello", "Test123", "Special chars: !@#$%", "Unicode: ä½ å¥½ä¸–ç•Œ"]

for test_str in test_strings {
    # Encode string as bytes, then to base64
    let as_bytes := decode_base64(encode_base64(test_str))
    let encoded := encode_base64(as_bytes)
    let decoded := decode_base64(encoded)
    let back_to_base64 := encode_base64(decoded)
    
    if encoded == back_to_base64 {
        print("âœ“ Base64 round-trip successful for: " + test_str)
    } else {
        print("âœ— Base64 round-trip failed for: " + test_str)
    }
}
print()

# Test 3: Binary file size handling
print("Test 3: Binary file with known size")
let size_test_file := "/tmp/ruff_binary_size_test.bin"

# Create binary data with specific pattern
let pattern := "ABC"
let pattern_bytes := decode_base64(encode_base64(pattern))

result := write_binary_file(size_test_file, pattern_bytes)
if result {
    let read_data := read_binary_file(size_test_file)
    let size := len(read_data)
    
    # Note: len() returns byte length, which should be 3 for "ABC"
    if size == 3.0 {
        print("âœ“ Binary file size is correct: 3 bytes")
    } else {
        print("âœ— Binary file size incorrect (expected 3 bytes)")
    }
} else {
    print("âœ— Failed to write size test file")
}
print()

# Test 4: Empty binary file
print("Test 4: Empty binary file handling")
let empty_file := "/tmp/ruff_empty_binary.bin"
let empty_bytes := decode_base64("")

result := write_binary_file(empty_file, empty_bytes)
if result {
    let read_empty := read_binary_file(empty_file)
    let empty_size := len(read_empty)
    
    if empty_size == 0.0 {
        print("âœ“ Empty binary file handled correctly")
    } else {
        print("âœ— Empty file has unexpected size")
    }
} else {
    print("âœ— Failed to write empty binary file")
}
print()

# Test 5: Large binary data
print("Test 5: Larger binary data handling")
let large_file := "/tmp/ruff_large_binary.bin"

# Create larger data by repeating a pattern
let chunk := "0123456789ABCDEF"
let repeated := chunk + chunk + chunk + chunk + chunk  # 80 chars
let large_bytes := decode_base64(encode_base64(repeated))

result := write_binary_file(large_file, large_bytes)
if result {
    let read_large := read_binary_file(large_file)
    let large_encoded := encode_base64(read_large)
    let original_encoded := encode_base64(large_bytes)
    
    if large_encoded == original_encoded {
        print("âœ“ Large binary data written and read correctly")
    } else {
        print("âœ— Large binary data mismatch")
    }
} else {
    print("âœ— Failed to write large binary file")
}
print()

# Test 6: Error handling - non-existent file
print("Test 6: Error handling for non-existent file")
let nonexistent := "/tmp/this_file_should_not_exist_ruff_binary_test_12345.bin"
let read_result := read_binary_file(nonexistent)

# Check if it's an error (the result should be an error value)
# In Ruff, errors are typically Error values, but we can check behavior
print("  Attempted to read non-existent file")
print("  (Error handling verified - function didn't crash)")
print()

# Test 7: Base64 with special characters
print("Test 7: Base64 with special patterns")
let special_data := "Line1\nLine2\tTabbed\rReturn"
let special_bytes := decode_base64(encode_base64(special_data))
let special_encoded := encode_base64(special_bytes)
let special_decoded := decode_base64(special_encoded)
let back_encoded := encode_base64(special_decoded)

if special_encoded == back_encoded {
    print("âœ“ Special characters (newlines, tabs) handled correctly")
} else {
    print("âœ— Special characters handling failed")
}
print()

# Test 8: Multiple file operations
print("Test 8: Multiple file operations")
let multi_file_1 := "/tmp/ruff_multi_1.bin"
let multi_file_2 := "/tmp/ruff_multi_2.bin"
let multi_file_3 := "/tmp/ruff_multi_3.bin"

let data1 := decode_base64(encode_base64("File1"))
let data2 := decode_base64(encode_base64("File2"))
let data3 := decode_base64(encode_base64("File3"))

r1 := write_binary_file(multi_file_1, data1)
r2 := write_binary_file(multi_file_2, data2)
r3 := write_binary_file(multi_file_3, data3)

if r1 && r2 && r3 {
    let content1 := encode_base64(read_binary_file(multi_file_1))
    let content2 := encode_base64(read_binary_file(multi_file_2))
    let content3 := encode_base64(read_binary_file(multi_file_3))
    
    let expected1 := encode_base64(data1)
    let expected2 := encode_base64(data2)
    let expected3 := encode_base64(data3)
    
    if content1 == expected1 && content2 == expected2 && content3 == expected3 {
        print("âœ“ Multiple binary files handled correctly")
    } else {
        print("âœ— Multiple file operations failed")
    }
} else {
    print("âœ— Failed to write multiple binary files")
}
print()

# Test 9: Binary data length function
print("Test 9: len() function with binary data")
let length_test_data := "12345"
let length_bytes := decode_base64(encode_base64(length_test_data))
let byte_length := len(length_bytes)

if byte_length == 5.0 {
    print("âœ“ len() correctly reports binary data length")
} else {
    print("âœ— len() returned incorrect length")
}
print()

# Test 10: Overwrite existing binary file
print("Test 10: Overwriting existing binary file")
let overwrite_file := "/tmp/ruff_overwrite_test.bin"

let first_data := decode_base64(encode_base64("First"))
let second_data := decode_base64(encode_base64("Second version - longer"))

write_binary_file(overwrite_file, first_data)
write_binary_file(overwrite_file, second_data)

let final_content := encode_base64(read_binary_file(overwrite_file))
let expected_final := encode_base64(second_data)

if final_content == expected_final {
    print("âœ“ Binary file overwrite successful")
} else {
    print("âœ— Binary file overwrite failed")
}
print()

print("=== Binary File Test Suite Complete ===")
