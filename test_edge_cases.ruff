# Test edge cases for JIT function compilation

print("=== Testing Edge Cases ===")
print("")

# Test 1: Function with no parameters
print("Test 1: Function with no parameters")
func get_constant() {
    return 42
}

result1 := get_constant()
print("get_constant() =", result1)
assert result1 == 42, "Test 1 failed"

# Call 100+ times to trigger JIT
for i in range(100) {
    val := get_constant()
    assert val == 42, "get_constant() inconsistent"
}
print("✓ Test 1 passed")
print("")

# Test 2: Function with many parameters
print("Test 2: Function with 5+ parameters")
func sum_five(a, b, c, d, e) {
    return a + b + c + d + e
}

result2 := sum_five(1, 2, 3, 4, 5)
print("sum_five(1, 2, 3, 4, 5) =", result2)
assert result2 == 15, "Test 2 failed"

# Call many times
for i in range(100) {
    val := sum_five(i, i+1, i+2, i+3, i+4)
    expected := i*5 + 10
    assert val == expected, "sum_five failed"
}
print("✓ Test 2 passed")
print("")

# Test 3: Function returning a constant (no computation)
print("Test 3: Function returning literal constant")
func return_zero() {
    return 0
}

func return_one() {
    return 1
}

func return_hundred() {
    return 100
}

assert return_zero() == 0, "return_zero failed"
assert return_one() == 1, "return_one failed"
assert return_hundred() == 100, "return_hundred failed"

# Trigger JIT for each
for i in range(100) {
    return_zero()
    return_one()
    return_hundred()
}

print("✓ Test 3 passed")
print("")

# Test 4: Function with local variables
print("Test 4: Function with local variables")
func compute_with_locals(x) {
    local1 := x * 2
    local2 := local1 + 5
    local3 := local2 * 3
    result := local3 - 10
    return result
}

result4 := compute_with_locals(10)
print("compute_with_locals(10) =", result4)
expected4 := ((10 * 2) + 5) * 3 - 10
assert result4 == expected4, "Test 4 failed"

# Trigger JIT
for i in range(100) {
    val := compute_with_locals(i)
    expected := ((i * 2) + 5) * 3 - 10
    assert val == expected, "compute_with_locals failed"
}
print("✓ Test 4 passed")
print("")

# Test 5: Function with only arithmetic
print("Test 5: Pure arithmetic function")
func pure_arithmetic(a, b) {
    return (a + b) * (a - b) + (a * b) / (a + 1)
}

result5 := pure_arithmetic(10, 5)
print("pure_arithmetic(10, 5) =", result5)

# Trigger JIT
sum := 0
for i in range(100) {
    sum := sum + pure_arithmetic(i+1, i)
}
print("Sum after 100 iterations:", sum)
print("✓ Test 5 passed")
print("")

# Test 6: Function calling itself (identity recursion)
print("Test 6: Identity recursion (depth check)")
func countdown(n) {
    if n <= 0 {
        return 0
    }
    return countdown(n - 1) + 1
}

result6 := countdown(10)
print("countdown(10) =", result6)
assert result6 == 10, "Test 6 failed"

# Test deeper recursion
result7 := countdown(20)
assert result7 == 20, "countdown(20) failed"
print("✓ Test 6 passed")
print("")

# Test 7: Function with conditionals
print("Test 7: Function with conditionals")
func max_of_three(a, b, c) {
    if a >= b and a >= c {
        return a
    }
    if b >= c {
        return b
    }
    return c
}

assert max_of_three(1, 2, 3) == 3, "max_of_three failed"
assert max_of_three(3, 2, 1) == 3, "max_of_three failed"
assert max_of_three(2, 3, 1) == 3, "max_of_three failed"
assert max_of_three(5, 5, 5) == 5, "max_of_three failed"

# Trigger JIT
for i in range(100) {
    max_of_three(i, i+1, i+2)
}
print("✓ Test 7 passed")
print("")

print("=== All Edge Case Tests PASSED! ===")
