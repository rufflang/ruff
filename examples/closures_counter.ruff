# Counter Closure Example
# Demonstrates closure capturing and maintaining state across calls

# Create a counter factory that returns a closure
func make_counter() {
    let count := 0
    return func() {
        count := count + 1
        return count
    }
}

# Create first counter
counter1 := make_counter()
print("Counter 1:")
print(counter1())  # Should print 1
print(counter1())  # Should print 2
print(counter1())  # Should print 3

# Create second counter - should be independent
counter2 := make_counter()
print("\nCounter 2:")
print(counter2())  # Should print 1
print(counter2())  # Should print 2

# First counter should still maintain its state
print("\nCounter 1 again:")
print(counter1())  # Should print 4

print("\nâœ“ Counter closure test complete!")
