#
# Lexical Scoping Examples for Ruff
#
# Demonstrates proper variable scoping with nested functions and loops
#

# Example 1: Accumulator Pattern (from ROADMAP)
print("=== Accumulator Pattern ===")
sum := 0
for n in [1, 2, 3, 4, 5] {
    sum := sum + n  # Updates outer 'sum', doesn't create new variable
    print("Current sum:", sum)
}
print("Final sum:", sum)
print()

# Example 2: Counter in Function
print("=== Function Counter ===")
counter := 0
func increment() {
    counter := counter + 1
}
print("Initial counter:", counter)
increment()
print("After 1 call:", counter)
increment()
increment()
print("After 3 calls:", counter)
print()

# Example 3: Variable Shadowing with 'let'
print("=== Variable Shadowing ===")
x := 10
print("Outer x:", x)

func test_shadow() {
    let x := 20  # Creates NEW local x, shadowing outer x
    print("Inner x (shadowed):", x)
    result := x * 2
}

test_shadow()
print("Outer x after function:", x)  # Still 10, unchanged
print()

# Example 4: Nested Functions
print("=== Nested Functions ===")
a := 1

func outer() {
    b := 2
    print("In outer: a =", a, "b =", b)
    
    func inner() {
        c := 3
        print("In inner: a =", a, "b =", b, "c =", c)
        
        # Can modify variables from outer scopes
        a := a + 10
        b := b + 10
    }
    
    inner()
    print("After inner: a =", a, "b =", b)
}

outer()
print("After outer: a =", a)
print()

# Example 5: For Loop Variable Isolation
print("=== For Loop Isolation ===")
for i in [1, 2, 3] {
    temp := i * 10
    print("Loop iteration:", i, "temp:", temp)
}
# i and temp don't exist outside the loop
print()

# Example 6: Accumulator with Multiplication
print("=== Factorial-like Pattern ===")
product := 1
for n in [2, 3, 4, 5] {
    product := product * n
    print("Current product:", product)
}
print("Final product:", product)
