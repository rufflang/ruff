# Path Module Examples
# Demonstrates path manipulation and file system query functions

print("=== Path Module Examples ===\n")

# ============================================================
# Example 1: Path Joining
# ============================================================

print("Example 1: Path Joining")
print("-" * 50)

# Join path components
let doc_path := path_join("home", "user", "documents")
print("Documents path: " + doc_path)

let config_file := path_join("etc", "app", "config.json")
print("Config file: " + config_file)

# Build nested paths
let data_file := path_join("data", "2024", "01", "metrics.csv")
print("Data file path: " + data_file)

# Join with filename
let script_path := path_join("scripts", "backup.sh")
print("Script path: " + script_path)

# ============================================================
# Example 2: Path Inspection
# ============================================================

print("\nExample 2: Path Inspection")
print("-" * 50)

# Create test files and directories
create_dir("test_paths")
write_file("test_paths/document.txt", "Sample content")
write_file("test_paths/image.png", "binary data")
write_file("test_paths/script.py", "print('hello')")
create_dir("test_paths/subfolder")

# Check what exists
let paths_to_check := array(
    "test_paths",
    "test_paths/document.txt",
    "test_paths/subfolder",
    "nonexistent_file.txt"
)

print("Checking paths:")
let i := 0
loop {
    if (i >= len(paths_to_check)) { break }
    
    let p := paths_to_check[i]
    let exists := path_exists(p)
    let is_file := path_is_file(p)
    let is_dir := path_is_dir(p)
    
    print("\n  Path: " + p)
    print("    Exists: " + to_string(exists))
    print("    Is file: " + to_string(is_file))
    print("    Is directory: " + to_string(is_dir))
    
    i := i + 1
}

# Cleanup
delete_file("test_paths/document.txt")
delete_file("test_paths/image.png")
delete_file("test_paths/script.py")
os_rmdir("test_paths/subfolder")
os_rmdir("test_paths")

# ============================================================
# Example 3: File Extension Extraction
# ============================================================

print("\nExample 3: File Extension Extraction")
print("-" * 50)

let files := array(
    "document.pdf",
    "image.jpeg",
    "archive.tar.gz",
    "script.py",
    "README",
    "config.json",
    "/path/to/file.txt"
)

print("Extracting extensions:")
let j := 0
loop {
    if (j >= len(files)) { break }
    
    let filename := files[j]
    let ext := path_extension(filename)
    
    if (len(ext) > 0) {
        print("  " + filename + " → ." + ext)
    } else {
        print("  " + filename + " → (no extension)")
    }
    
    j := j + 1
}

# ============================================================
# Example 4: File Type Filtering
# ============================================================

print("\nExample 4: File Type Filtering")
print("-" * 50)

# Create test directory with mixed files
create_dir("file_filter_test")
write_file("file_filter_test/data.json", "{}")
write_file("file_filter_test/script.py", "# python")
write_file("file_filter_test/document.txt", "text")
write_file("file_filter_test/image.png", "png")
write_file("file_filter_test/notes.md", "# notes")

func filter_by_extension(directory, extension) {
    let all_files := list_dir(directory)
    let filtered := array()
    
    let i := 0
    loop {
        if (i >= len(all_files)) { break }
        
        let filename := all_files[i]
        let full_path := path_join(directory, filename)
        
        # Only process files, not directories
        if (path_is_file(full_path)) {
            let file_ext := path_extension(filename)
            
            if (file_ext == extension) {
                push(filtered, filename)
            }
        }
        
        i := i + 1
    }
    
    return filtered
}

# Filter for Python files
let python_files := filter_by_extension("file_filter_test", "py")
print("Python files (.py):")
let k := 0
loop {
    if (k >= len(python_files)) { break }
    print("  - " + python_files[k])
    k := k + 1
}

# Filter for Markdown files  
let md_files := filter_by_extension("file_filter_test", "md")
print("\nMarkdown files (.md):")
let m := 0
loop {
    if (m >= len(md_files)) { break }
    print("  - " + md_files[m])
    m := m + 1
}

# Cleanup
delete_file("file_filter_test/data.json")
delete_file("file_filter_test/script.py")
delete_file("file_filter_test/document.txt")
delete_file("file_filter_test/image.png")
delete_file("file_filter_test/notes.md")
os_rmdir("file_filter_test")

# ============================================================
# Example 5: Absolute Path Resolution
# ============================================================

print("\nExample 5: Absolute Path Resolution")
print("-" * 50)

# Create a test file
write_file("temp_abs_test.txt", "test")

# Get absolute path
let abs_path := path_absolute("temp_abs_test.txt")
print("Relative path: temp_abs_test.txt")
print("Absolute path: " + abs_path)

# Verify it's actually absolute
if (contains(abs_path, "/")) {
    print("✓ Path is absolute (contains /)")
}

if (len(abs_path) > len("temp_abs_test.txt")) {
    print("✓ Absolute path is longer than relative")
}

# Cleanup
delete_file("temp_abs_test.txt")

# ============================================================
# Example 6: Path-based File Organization
# ============================================================

print("\nExample 6: Path-based File Organization")
print("-" * 50)

func organize_files_by_type(source_dir) {
    print("Organizing files in: " + source_dir)
    
    # Create organization structure
    let type_dirs := dict()
    type_dirs["txt"] := path_join(source_dir, "text_files")
    type_dirs["py"] := path_join(source_dir, "python_scripts")
    type_dirs["json"] := path_join(source_dir, "data_files")
    type_dirs["md"] := path_join(source_dir, "markdown_docs")
    
    # Create type directories
    create_dir(type_dirs["txt"])
    create_dir(type_dirs["py"])
    create_dir(type_dirs["json"])
    create_dir(type_dirs["md"])
    
    print("Created organization directories:")
    print("  - text_files/")
    print("  - python_scripts/")
    print("  - data_files/")
    print("  - markdown_docs/")
    
    return type_dirs
}

# Create test files
create_dir("organize_test")
write_file("organize_test/readme.md", "# README")
write_file("organize_test/script.py", "# script")
write_file("organize_test/data.json", "{}")
write_file("organize_test/notes.txt", "notes")

# Organize them
let organized := organize_files_by_type("organize_test")

print("\n✓ File organization structure created")

# Cleanup
delete_file("organize_test/readme.md")
delete_file("organize_test/script.py")
delete_file("organize_test/data.json")
delete_file("organize_test/notes.txt")
os_rmdir("organize_test/text_files")
os_rmdir("organize_test/python_scripts")
os_rmdir("organize_test/data_files")
os_rmdir("organize_test/markdown_docs")
os_rmdir("organize_test")

# ============================================================
# Example 7: Build Path from Components
# ============================================================

print("\nExample 7: Build Path from Components")
print("-" * 50)

func build_project_paths(project_name, version) {
    let paths := dict()
    
    # Build various project paths
    paths["root"] := project_name
    paths["src"] := path_join(project_name, "src")
    paths["tests"] := path_join(project_name, "tests")
    paths["docs"] := path_join(project_name, "docs")
    paths["build"] := path_join(project_name, "build", version)
    paths["dist"] := path_join(project_name, "dist", version)
    
    return paths
}

# Generate paths for a project
let project_paths := build_project_paths("myapp", "1.0.0")

print("Generated project paths:")
print("  Root: " + project_paths["root"])
print("  Source: " + project_paths["src"])
print("  Tests: " + project_paths["tests"])
print("  Docs: " + project_paths["docs"])
print("  Build: " + project_paths["build"])
print("  Dist: " + project_paths["dist"])

# ============================================================
# Example 8: Cross-platform Path Handling
# ============================================================

print("\nExample 8: Cross-platform Path Handling")
print("-" * 50)

func normalize_path(components) {
    # path_join handles platform differences automatically
    # This demonstrates passing multiple components
    
    let i := 0
    let parts := array()
    
    loop {
        if (i >= len(components)) { break }
        push(parts, components[i])
        i := i + 1
    }
    
    # Build path using the first component
    if (len(parts) == 0) {
        return ""
    }
    
    if (len(parts) == 1) {
        return parts[0]
    }
    
    if (len(parts) == 2) {
        return path_join(parts[0], parts[1])
    }
    
    if (len(parts) == 3) {
        return path_join(parts[0], parts[1], parts[2])
    }
    
    # For more components, chain path_join calls
    let result := path_join(parts[0], parts[1])
    i := 2
    loop {
        if (i >= len(parts)) { break }
        result := path_join(result, parts[i])
        i := i + 1
    }
    
    return result
}

# Test with different path components
let components1 := array("home", "user", "documents", "file.txt")
let normalized1 := normalize_path(components1)
print("Normalized path 1: " + normalized1)

let components2 := array("var", "log", "app", "error.log")
let normalized2 := normalize_path(components2)
print("Normalized path 2: " + normalized2)

# ============================================================
# Example 9: File Discovery
# ============================================================

print("\nExample 9: File Discovery")
print("-" * 50)

func find_files_with_extension(directory, ext) {
    let results := array()
    
    if (!path_is_dir(directory)) {
        print("Error: " + directory + " is not a directory")
        return results
    }
    
    let files := list_dir(directory)
    
    let i := 0
    loop {
        if (i >= len(files)) { break }
        
        let filename := files[i]
        let full_path := path_join(directory, filename)
        
        if (path_is_file(full_path)) {
            let file_ext := path_extension(filename)
            if (file_ext == ext) {
                push(results, filename)
            }
        }
        
        i := i + 1
    }
    
    return results
}

# Create test directory
create_dir("discovery_test")
write_file("discovery_test/app.py", "# app")
write_file("discovery_test/test.py", "# test")
write_file("discovery_test/utils.py", "# utils")
write_file("discovery_test/README.md", "# docs")
write_file("discovery_test/data.json", "{}")

# Find all Python files
let python_scripts := find_files_with_extension("discovery_test", "py")
print("Found Python files:")
let n := 0
loop {
    if (n >= len(python_scripts)) { break }
    print("  - " + python_scripts[n])
    n := n + 1
}

# Cleanup
delete_file("discovery_test/app.py")
delete_file("discovery_test/test.py")
delete_file("discovery_test/utils.py")
delete_file("discovery_test/README.md")
delete_file("discovery_test/data.json")
os_rmdir("discovery_test")

print("\n" + "=" * 50)
print("Path Module Examples Complete!")
print("=" * 50)
