# Struct Method Self Parameter - Comprehensive Example

# Example 1: Builder Pattern
# Methods can return modified instances for method chaining

struct Builder {
    x: float,
    y: float,
    
    func set_x(self, value) {
        return Builder { x: value, y: self.y };
    }
    
    func set_y(self, value) {
        return Builder { x: self.x, y: value };
    }
    
    func display(self) {
        print("Builder { x:");
        print(self.x);
        print(", y:");
        print(self.y);
        print("}");
        return self;
    }
}

print("=== Builder Pattern Example ===");
builder := Builder { x: 0.0, y: 0.0 };
builder2 := builder.set_x(10.0);
builder3 := builder2.set_y(20.0);
final := builder3.display();

# Example 2: Method Composition
# Methods can call other methods on the same instance

struct Calculator {
    base: float,
    
    func add(self, x) {
        return self.base + x;
    }
    
    func multiply(self, x) {
        return self.base * x;
    }
    
    func add_then_multiply(self, add_val, mult_val) {
        # Call add method
        temp := self.add(add_val);
        # Multiply the result
        return temp * mult_val;
    }
    
    func complex_calc(self, x, y) {
        # Multiple method calls
        result1 := self.add(x);
        result2 := self.multiply(y);
        return result1 + result2;
    }
}

print("\n=== Method Composition Example ===");
calc := Calculator { base: 10.0 };
print("Base: 10.0");

print("add(5):");
print(calc.add(5.0));  # 15.0

print("multiply(3):");
print(calc.multiply(3.0));  # 30.0

print("add_then_multiply(5, 2):");
print(calc.add_then_multiply(5.0, 2.0));  # (10+5)*2 = 30.0

print("complex_calc(5, 3):");
print(calc.complex_calc(5.0, 3.0));  # (10+5) + (10*3) = 45.0

# Example 3: Backward Compatibility
# Methods without self parameter still work (direct field access)

struct OldStyle {
    value: float,
    
    func double() {
        return value * 2.0;
    }
    
    func triple() {
        return value * 3.0;
    }
}

print("\n=== Backward Compatibility Example ===");
old := OldStyle { value: 7.0 };
print("Value: 7.0");

print("double():");
print(old.double());  # 14.0

print("triple():");
print(old.triple());  # 21.0

# Example 4: self with operator overloading

struct Vec2 {
    x: float,
    y: float,
    
    func op_add(self, other) {
        return Vec2 { x: self.x + other.x, y: self.y + other.y };
    }
    
    func op_mul(self, scalar) {
        return Vec2 { x: self.x * scalar, y: self.y * scalar };
    }
    
    func magnitude(self) {
        return sqrt(self.x * self.x + self.y * self.y);
    }
    
    func display(self) {
        print("Vec2 { x:");
        print(self.x);
        print(", y:");
        print(self.y);
        print("}");
    }
}

print("\n=== Operator Overloading with self Example ===");
v1 := Vec2 { x: 3.0, y: 4.0 };
v2 := Vec2 { x: 1.0, y: 2.0 };

print("v1:");
v1.display();

print("v2:");
v2.display();

print("v1 + v2:");
v3 := v1 + v2;
v3.display();

print("v1 * 2.0:");
v4 := v1 * 2.0;
v4.display();

print("v1.magnitude():");
mag := v1.magnitude();
print(mag);  # 5.0

print("\n✅ All examples completed successfully!");


# Example 2: Method Composition
# Methods can call other methods on the same instance

struct Calculator {
    base: float,
    
    func add(self, x) {
        return self.base + x;
    }
    
    func multiply(self, x) {
        return self.base * x;
    }
    
    func add_then_multiply(self, add_val, mult_val) {
        # Call add method
        temp := self.add(add_val);
        # Multiply the result
        return temp * mult_val;
    }
    
    func complex_calc(self, x, y) {
        # Multiple method calls
        result1 := self.add(x);
        result2 := self.multiply(y);
        return result1 + result2;
    }
}

print("\n=== Method Composition Example ===");
calc := Calculator { base: 10.0 };
print("Base: 10.0");
print("add(5) = " + str(calc.add(5.0)));  # 15.0
print("multiply(3) = " + str(calc.multiply(3.0)));  # 30.0
print("add_then_multiply(5, 2) = " + str(calc.add_then_multiply(5.0, 2.0)));  # (10+5)*2 = 30.0
print("complex_calc(5, 3) = " + str(calc.complex_calc(5.0, 3.0)));  # (10+5) + (10*3) = 45.0

# Example 3: Fluent Interface for Data Validation

struct Validator {
    value: float,
    is_valid: bool,
    error_msg: string,
    
    func check_positive(self) {
        if (self.value <= 0.0) {
            return Validator { 
                value: self.value, 
                is_valid: false, 
                error_msg: "Value must be positive" 
            };
        }
        return self;
    }
    
    func check_max(self, max_val) {
        if (self.is_valid && self.value > max_val) {
            return Validator { 
                value: self.value, 
                is_valid: false, 
                error_msg: "Value exceeds maximum" 
            };
        }
        return self;
    }
    
    func get_result(self) {
        if (self.is_valid) {
            print("✓ Validation passed: " + str(self.value));
        } else {
            print("✗ Validation failed: " + self.error_msg);
        }
        return self.is_valid;
    }
}

print("\n=== Fluent Validation Example ===");
print("Validating 50.0 (should pass):");
valid1 := Validator { value: 50.0, is_valid: true, error_msg: "" }
    .check_positive()
    .check_max(100.0)
    .get_result();

print("\nValidating 150.0 (should fail - exceeds max):");
valid2 := Validator { value: 150.0, is_valid: true, error_msg: "" }
    .check_positive()
    .check_max(100.0)
    .get_result();

print("\nValidating -10.0 (should fail - not positive):");
valid3 := Validator { value: -10.0, is_valid: true, error_msg: "" }
    .check_positive()
    .check_max(100.0)
    .get_result();

# Example 4: Backward Compatibility
# Methods without self parameter still work (direct field access)

struct OldStyle {
    value: float,
    
    func double() {
        return value * 2.0;
    }
    
    func triple() {
        return value * 3.0;
    }
}

print("\n=== Backward Compatibility Example ===");
old := OldStyle { value: 7.0 };
print("Value: 7.0");
print("double() = " + str(old.double()));  # 14.0
print("triple() = " + str(old.triple()));  # 21.0

# Example 5: self with operator overloading

struct Vec2 {
    x: float,
    y: float,
    
    func op_add(self, other) {
        return Vec2 { x: self.x + other.x, y: self.y + other.y };
    }
    
    func op_mul(self, scalar) {
        return Vec2 { x: self.x * scalar, y: self.y * scalar };
    }
    
    func magnitude(self) {
        return sqrt(self.x * self.x + self.y * self.y);
    }
    
    func normalize(self) {
        mag := self.magnitude();
        if (mag > 0.0) {
            return Vec2 { x: self.x / mag, y: self.y / mag };
        }
        return self;
    }
}

print("\n=== Operator Overloading with self Example ===");
v1 := Vec2 { x: 3.0, y: 4.0 };
v2 := Vec2 { x: 1.0, y: 2.0 };
print("v1 = Vec2(3.0, 4.0)");
print("v2 = Vec2(1.0, 2.0)");

v3 := v1 + v2;
print("v1 + v2 = Vec2(" + str(v3.x) + ", " + str(v3.y) + ")");  # Vec2(4.0, 6.0)

v4 := v1 * 2.0;
print("v1 * 2.0 = Vec2(" + str(v4.x) + ", " + str(v4.y) + ")");  # Vec2(6.0, 8.0)

mag := v1.magnitude();
print("v1.magnitude() = " + str(mag));  # 5.0

normalized := v1.normalize();
print("v1.normalize() = Vec2(" + str(normalized.x) + ", " + str(normalized.y) + ")");

print("\n✅ All examples completed successfully!");
